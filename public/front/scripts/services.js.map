{"version":3,"sources":["bodyServices.js","mapService.js","localizationMapService.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"services.js","sourcesContent":["interMap.service('interMapAPI', [], function () {\n\n});\n\n","interMap.factory('MapService', function ($rootScope, $timeout, $q, $translate) {\n    var map, drawnItems, editMode;\n\n    var MAP_MIN_HEIGHT = 500;\n    var MAP_VERT_MARGIN = 60;\n\n    // Leaflet Locale\n    L.drawLocal.draw.handlers.polyline.tooltip.start = $translate.instant('MAP.LINE_START');\n    L.drawLocal.draw.handlers.polyline.tooltip.cont = $translate.instant('MAP.LINE_END');\n\n    L.drawLocal.draw.handlers.polygon.tooltip.start = $translate.instant('MAP.AREA_START');\n    L.drawLocal.draw.handlers.polygon.tooltip.cont = $translate.instant('MAP.AREA_CONT');\n    L.drawLocal.draw.handlers.polygon.tooltip.end = $translate.instant('MAP.AREA_END');\n\n    L.drawLocal.draw.handlers.marker.tooltip.start = $translate.instant('MAP.BEACON');\n\n    L.drawLocal.edit.handlers.edit.tooltip.text = $translate.instant('MAP.MOVE_TEXT');\n    L.drawLocal.edit.handlers.edit.tooltip.subtext = $translate.instant('MAP.MOVE_SUBTEXT');\n\n    var getCurrentRatio = function (level) {\n        var containerWidth = map._container.clientWidth,\n                containerHeight = map._container.clientHeight,\n                ratioX = containerHeight / level.map_height,\n                ratioY = containerWidth / level.map_width,\n                ratio = ratioY,\n                newMapHeight = ratioY * level.map_height;\n\n        // If map is higher than container height, scale it!\n        if (newMapHeight > containerHeight) {\n            ratio = ratioX;\n        }\n\n        return ratio;\n    };\n\n    return {\n        getMap: function () {\n            return map;\n        },\n        initMap: function (id) {\n            /***  little hack starts here ***/\n            L.Map = L.Map.extend({\n                openPopup: function (popup) {\n                    //        this.closePopup();  // just comment this\n                    this._popup = popup;\n\n                    return this.addLayer(popup).fire('popupopen', {\n                        popup: this._popup\n                    });\n                }\n            }); /***  end of hack ***/\n\n            map = new L.Map(id, {\n                crs: L.CRS.Simple,\n                center: [0, 0],\n                maxZoom: 2,\n                fullscreenControl: true\n            });\n\n            // Initialise the FeatureGroup to store editable layers\n            drawnItems = new L.FeatureGroup();\n            map.addLayer(drawnItems);\n\n            // Initialise the draw control\n            var drawControl = new L.Control.Draw({\n                draw: {\n                    polyline: false,\n                    polygon: false,\n                    circle: false,\n                    rectangle: false,\n                    marker: false\n                },\n                edit: false\n            });\n\n            editMode = new L.EditToolbar.Edit(map, {\n                featureGroup: drawnItems\n            });\n\n            map.addControl(drawControl);\n\n            // Whenever something is drawn\n            map.on('draw:created', function (e) {\n                $rootScope.$broadcast('elementDrawn', {layer: e.layer, type: e.layerType});\n            });\n\n            map.on('draw:edited', function (e) {\n                $rootScope.$broadcast('elementsEdited', e.layers);\n            });\n\n            map.invalidateSize();\n            // Update leaflet map height\n            var isSupportedBrowser = !(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > 0);\n            if (isSupportedBrowser) {\n                map.on('resize', function () {\n                    var newMapHeight = $(window).height() - $('#header').height() - MAP_VERT_MARGIN;\n                    $('#' + id).height(newMapHeight > MAP_MIN_HEIGHT ? newMapHeight : MAP_MIN_HEIGHT);\n                    map.invalidateSize();\n                    map.fire('dragstart');\n                    map.fire('drage');\n                    map.fire('dragend');\n                });\n            }\n\n            // Update Maps event - trigger 'resize' event to invalidate map size\n//                $rootScope.$on('updateMaps', function () {\n            $timeout(function () {\n                window.dispatchEvent(new Event('resize'));\n//                    });\n            });\n\n            return map;\n        },\n        removeMap: function () {\n            if (angular.isDefined(map)) {\n                map.remove();\n            }\n            map = undefined;\n            drawnItems = undefined;\n        },\n        loadPlan: function (level) {\n            var defer = $q.defer(),\n                    MapService = this;\n\n            MapService.resetMap();\n            if (angular.isNullOrUndefined(level.map_width) || angular.isNullOrUndefined(level.map_height)) {\n                defer.reject('Level plan dimensions are not defined!');\n            } else {\n                $timeout(function () {\n                    var containerWidth = map._container.clientWidth,\n                            ratio = containerWidth * level.map_height / level.map_width;\n                    map.options.maxZoom = Math.round(level.map_width / containerWidth / 2) + 1;\n//                        var southWest = map.unproject([0, -ratio], map.getMinZoom());\n                    var northEast = map.unproject([containerWidth, 0], map.getMinZoom());\n                    var southWest = map.unproject([0, -level.map_height], map.getMinZoom());\n//                        var northEast = map.unproject([level.map_width, 0], map.getMinZoom());\n                    var bounds = new L.LatLngBounds(southWest, northEast);\n\n                    MapService.resetMap();\n                    L.imageOverlay(level.map_path, bounds).addTo(map);\n\n                    map.setMaxBounds(bounds);\n                    map.fitBounds(bounds);\n\n//                        MapService.fitMap();\n                    MapService.onResize(level, function (newMapWidth, newMapHeight) {\n                        map.options.maxZoom = Math.round(level.map_width / newMapWidth / 2) + 1;\n\n                        var southWest = map.unproject([0, -newMapHeight], map.getMinZoom());\n                        var northEast = map.unproject([newMapWidth, 0], map.getMinZoom());\n                        var bounds = new L.LatLngBounds(southWest, northEast);\n\n                        MapService.resetMap();\n                        L.imageOverlay(level.map_path, bounds).addTo(map);\n                        map.setMaxBounds(bounds);\n                        map.fitBounds(bounds);\n                    });\n\n                    defer.resolve('Map is loaded.');\n                });\n            }\n            return defer.promise;\n        },\n        resetMap: function () {\n            map.eachLayer(function (layer) {\n                map.removeLayer(layer);\n            });\n        },\n        fitMap: function () {\n            // Hack below, new elements are added only after browser window resize (?!)\n            map._onResize();\n        },\n        getLayer: function (layerId) {\n            var _layer;\n            map.eachLayer(function (layer) {\n                if (parseInt(layer._leaflet_id) === parseInt(layerId)) {\n                    _layer = layer;\n                }\n            });\n            return _layer;\n        },\n        addLayer: function (layer, additionalLayer) {\n            map.addLayer(layer);\n            drawnItems.addLayer(additionalLayer ? additionalLayer : layer);\n        },\n        removeLayer: function (layerId) {\n            map.eachLayer(function (layer) {\n                if (layer._leaflet_id === layerId) {\n                    map.removeLayer(layer);\n                }\n            });\n            drawnItems.eachLayer(function (layer) {\n                if (layer._leaflet_id === layerId) {\n                    drawnItems.removeLayer(layer);\n                }\n            });\n        },\n        enableEditLayersMode: function () {\n            this.disableFullScreen();\n            editMode.enable();\n        },\n        cancelEdit: function () {\n            this.enableFullScreen();\n            editMode.revertLayers();\n            editMode.disable();\n        },\n        saveEditedLayers: function () {\n            this.enableFullScreen();\n            editMode.save();\n            editMode.disable();\n        },\n        getLayerOptions: function (type) {\n            switch (type.toLowerCase()) {\n                case 'area':\n                    return {color: '#ffff00'};\n                case 'distance':\n                    return {color: '#ff0000'};\n                case 'connection':\n                    return {color: '#ff0000'};\n                default:\n                    throw new Error('No such layer type in getLayerOptions function!');\n            }\n        },\n        createMarkerIcon: function (type) {\n            var options;\n            switch (type) {\n                case 'start':\n                    options = {prefix: 'li', icon: 'flag-o', markerColor: 'red'};\n                    break;\n                case 'end':\n                    options = {prefix: 'li', icon: 'flag-goal', markerColor: 'green'};\n                    break;\n                case 'beacon':\n                    options = {prefix: 'fa', icon: 'fa-dot-circle-o', markerColor: 'blue'};\n                    break;\n                case 'location':\n                    options = {prefix: 'li', icon: 'beacon', markerColor: 'blue'};\n                    break;\n                case 'beacon-selected':\n                    options = {prefix: 'li', icon: 'beacon', markerColor: 'green'};\n                    break;\n                case 'node':\n                    options = {prefix: 'li', icon: 'plus', markerColor: 'blue'};\n                    break;\n                case 'node-selected':\n                    options = {prefix: 'li', icon: 'plus', markerColor: 'green'};\n                    break;\n                case 'node-1':\n                    options = {prefix: 'li', icon: 'flag-goal', markerColor: 'red'};\n                    break;\n                case 'node-1-selected':\n                    options = {prefix: 'li', icon: 'flag-goal', markerColor: 'green'};\n                    break;\n                case 'node-2':\n                    options = {prefix: 'li', icon: 'plus', markerColor: 'blue'};\n                    break;\n                case 'node-2-selected':\n                    options = {prefix: 'li', icon: 'plus', markerColor: 'green'};\n                    break;\n                case 'node-3':\n                    options = {prefix: 'li', icon: 'exit', markerColor: 'blue'};\n                    break;\n                case 'node-3-selected':\n                    options = {prefix: 'li', icon: 'exit', markerColor: 'green'};\n                    break;\n                case 'node-4':\n                    options = {prefix: 'li', icon: 'stairs', markerColor: 'blue'};\n                    break;\n                case 'node-4-selected':\n                    options = {prefix: 'li', icon: 'stairs', markerColor: 'green'};\n                    break;\n                case 'node-5':\n                    options = {prefix: 'li', icon: 'elevator', markerColor: 'blue'};\n                    break;\n                case 'node-5-selected':\n                    options = {prefix: 'li', icon: 'elevator', markerColor: 'green'};\n                    break;\n                default:\n                    throw new Error('No such marker type in createMarkerIcon function!');\n            }\n            angular.extend(options, {className: 'appsoup-marker'});\n\n            return L.AwesomeMarkers.icon(options);\n        },\n        enableFullScreen: function () {\n            $('.leaflet-control-fullscreen').removeClass('fullscreen-disabled');\n        },\n        disableFullScreen: function () {\n            $('.leaflet-control-fullscreen').addClass('fullscreen-disabled');\n        },\n        isFullscreenOn: function () {\n            return map.isFullscreen();\n        },\n        /*\n         * PROJECTION, SCALING map\n         * -----------------------\n         * - onResize: function that scales the map image to the specific browser resolution\n         * - pointToLatLng: maps point to real LatLng (according to the real image map size)\n         * - pointFromLatLng: maps real LatLng coordinates (stored in database) into scaled map displayed to user\n         */\n        onResize: function (level, callback) {\n            map.on('resize', function () {\n                $timeout(function () {\n                    var containerWidth = map._container.clientWidth,\n                            containerHeight = map._container.clientHeight,\n                            ratioX = containerHeight / level.map_height,\n                            ratioY = containerWidth / level.map_width,\n                            newMapWidth = containerWidth,\n                            newMapHeight = ratioY * level.map_height;\n\n\n                    if (newMapHeight > containerHeight) {\n                        newMapHeight = containerHeight;\n                        newMapWidth = ratioX * level.map_width;\n                    }\n\n                    callback(newMapWidth, newMapHeight);\n                });\n            });\n        },\n        pointToLatLng: function (point, level) {\n            var actualPoint = {},\n                    ratio = getCurrentRatio(level);\n            if (angular.isArray(point) && point.length > 0) {\n                actualPoint = {\n                    lng: parseInt(point[0] * ratio),\n                    lat: parseInt(point[1] * ratio)\n                };\n            }\n            return actualPoint;\n        },\n        pointFromLatLng: function (point, level) {\n            var actualX, actualY,\n                    ratio = getCurrentRatio(level);\n\n            if (angular.isDefined(point) && angular.isDefined(point.lng) && angular.isDefined(point.lat)) {\n                actualX = parseInt(point.lng / ratio);\n                actualY = parseInt(point.lat / ratio);\n            }\n\n            return [actualX, actualY];\n        }\n    };\n    \n    return interMap;\n\n});","interMap.factory('LocalizationMapService', ['$rootScope', '$timeout', '$filter', 'MapService', function ($rootScope, $timeout, $filter, MapService) {\n\n    var drawnItems;\n    var _getIconClass = function (className) {\n        return '<i class=\"li-fw ' + className + '\"></i> ';\n    };\n    var _getLocationTooltip = function (text, type) {\n        var label = '';\n        switch (type) {\n            case 'visits':\n                label = _getIconClass('li-users') + text;\n                break;\n            case 'time_spent':\n                label = _getIconClass('li-clock') + $filter('humanizeTime')(text, 'seconds');\n                break;\n            case 'new':\n                label = _getIconClass('li-users-new') + text;\n                break;\n            case 'unique':\n                label = _getIconClass('li-users-unique') + text;\n                break;\n            case 'returning':\n                label = _getIconClass('li-users-return') + text;\n                break;\n            default:\n                label = '';\n        }\n\n        return label;\n    };\n    var LocalizationMapService = {\n        map: null,\n        MAP_MIN_HEIGHT: 500,\n        MAP_VERT_MARGIN: 60,\n        defaultZoom: 6,\n        maxZoom: 18,\n        defaultLat: 52.2333,\n        defaultLng: 21.0167,\n        circleDrawer: null,\n        newLayers: null,\n        initMap: function (mapElementId, latLng, zoom) {\n            mapElementId = typeof mapElementId !== 'undefined' ? mapElementId : 'map';\n            latLng = typeof latLng !== 'undefined' ? latLng : [this.defaultLat, this.defaultLng];\n            zoom = typeof zoom !== 'undefined' ? zoom : this.defaultZoom;\n            this.map = L.map(mapElementId);\n            // Update leaflet map height\n            this.resizeAfterLoad(mapElementId);\n            this.map.addLayer(new L.TileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'));\n            this.changeView(latLng[0], latLng[1], zoom);\n            // Initialise the FeatureGroup to store editable layers\n            drawnItems = new L.FeatureGroup();\n            this.map.addLayer(drawnItems);\n            this.map.on('draw:created', function (e) {\n                $rootScope.$broadcast('elementDrawn', {layer: e.layer, type: e.layerType});\n            });\n            $timeout(function () {\n                this.getMap().invalidateSize();\n            }.bind(this), 0);\n        },\n        /**\n         * Wyświetlenie innej części mapy\n         * @param float lat\n         * @param float lng\n         * @param int zoom\n         */\n        changeView: function (lat, lng, zoom) {\n            if (typeof zoom === 'undefined')\n                zoom = this.maxZoom;\n            if (typeof lat === 'undefined')\n                lat = this.defaultLat;\n            if (typeof lng === 'undefined')\n                lng = this.defaultLng;\n            this.map.setView(new L.LatLng(lat, lng), zoom);\n        },\n        zoomByRadius: function (radius) {\n            if (radius < 100)\n                return this.maxZoom;\n            if (radius < 1000)\n                return 15;\n            if (radius < 10000)\n                return 11;\n            if (radius < 30000)\n                return 9;\n            return this.defaultZoom;\n        },\n        /**\n         * This is mostly to fix angular and leaflet issues\n         * invalidateSize on resize\n         */\n        resizeAfterLoad: function (mapElementId) {\n            var isSupportedBrowser = !(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > 0);\n            if (isSupportedBrowser) {\n                this.map.on('resize', function () {\n                    var newMapHeight = $(window).height() - $('#header').height() - this.MAP_VERT_MARGIN;\n                    $('#' + mapElementId).height(newMapHeight > this.MAP_MIN_HEIGHT ? newMapHeight : this.MAP_MIN_HEIGHT);\n                    this.map.invalidateSize();\n                }.bind(this));\n            }\n\n            $rootScope.$on('updateMaps', function () {\n                $timeout(function () {\n                    window.dispatchEvent(new Event('resize'));\n                });\n            });\n        },\n        /**\n         * Zwraca mapę leafleta\n         */\n        getMap: function () {\n            return this.map;\n        },\n        /**\n         * Rysuje koło dla lokalizacji i kieruje na odpowiednie współrzędne\n         * @param localization\n         */\n        displayLocalization: function (localization) {\n            localization.point_lat_lng = [localization.lat, localization.lng];\n            var circle = L.circle(localization.point_lat_lng, localization.radius);\n            circle.off('click').on('click', function () {\n                $rootScope.$broadcast('elementEdit', localization);\n            });\n            circle.addTo(this.map);\n            return circle;\n        },\n        /**\n         * Rysuje koła dla tablicy lokalizacji\n         * @param array localizations\n         * @param bool editEnabled\n         */\n        displayLocalizations: function (localizations) {\n            localizations.forEach(function (localization) {\n                localization.point_lat_lng = [localization.lat, localization.lng];\n                var circle = L.circle(localization.point_lat_lng, localization.radius);\n\n                // Tooltips For Localizations\n                var popup = new L.Popup();\n                popup.setContent('<p><b>' + localization.name + '</b>');\n                circle.bindPopup(popup, {autoPan: true, closeButton: false});\n                circle.on('mouseover', function (e) {\n                    this.openPopup();\n                });\n//                    circle.on('mouseout', function (e) {\n//                        this.closePopup();\n//                    });\n\n                circle.addTo(this.map);\n                localization._leaflet_id = circle._leaflet_id;\n            }.bind(this));\n            return localizations;\n        },\n        /**\n         * Czyści mapę z lokalizacji\n         */\n        clearMap: function () {\n            for (var i in this.map._layers) {\n                if (this.map._layers[i]._path != undefined) {\n                    try {\n                        this.map.removeLayer(this.map._layers[i]);\n                    } catch (e) {\n                        //console.log(\"problem with \" + e + this.map._layers[i]);\n                    }\n                }\n            }\n        },\n        /**\n         * Usuwa element z mapy\n         * @param layerId\n         */\n        removeElement: function (layerId) {\n            this.map.eachLayer(function (layer) {\n                if (layer._leaflet_id === layerId) {\n                    this.map.removeLayer(layer);\n                }\n            }.bind(this));\n        },\n        /**\n         * Odpala rysowanie okręgu - lokalizacji\n         */\n        enableLocalizationSelector: function () {\n            this.circleDrawer = new L.Draw.Circle(this.map, {});\n            this.circleDrawer.enable();\n        },\n        /**\n         * Kończy rysowanie okręgu - lokalizacji\n         */\n        disableLocalizationSelector: function () {\n            if (!angular.isNullOrUndefined(this.circleDrawer)) {\n                this.circleDrawer.disable();\n            }\n        },\n        /**\n         * Przerywa rysowanie elementu\n         */\n        cancelElement: function () {\n            if (!angular.isNullOrUndefined(this.circleDrawer)) {\n                this.circleDrawer.disable();\n            }\n            if (!angular.isNullOrUndefined(this.newLayers)) {\n                this.newLayers.eachLayer(function (layer) {\n                    this.map.removeLayer(layer);\n                });\n                this.newLayers = null;\n            }\n        },\n        addLayer: function (layer, additionalLayer) {\n            this.map.addLayer(layer);\n            drawnItems.addLayer(additionalLayer ? additionalLayer : layer);\n        },\n        showLocations: function (locations, type) {\n            LocalizationMapService.clearMap();\n//                LocalizationMapService.displayLocalizations(locations, true);\n\n            var markers = new L.MarkerClusterGroup({\n                iconCreateFunction: function (cluster) {\n                    var nodes = cluster.getAllChildMarkers(),\n                            amount = 0,\n                            count = 0;\n                    angular.forEach(nodes, function (node) {\n                        var location = node.options.location_data;\n                        if (angular.isDefined(location)) {\n                            amount = amount + location[type];\n                            count = count + 1;\n                        }\n                    });\n                    if (type === 'time_spent') {\n                        amount = amount / count;\n                        amount = $filter('humanizeTime')(amount, 'seconds');\n                        amount = amount.replace(\" \", \"&nbsp;\");\n                    }\n\n                    return new L.DivIcon({\n                        html: '<div><span>' + amount + '</span></div>',\n                        className: 'marker-cluster marker-cluster-small',\n                        iconSize: new L.Point(40, 40)\n                    });\n                }\n            });\n            var newMapWidth = this.map._size.x / 10;\n            var maxValue = 0;\n            var heatMapData = [];\n            var cfg = {\n                radius: 1,\n                maxOpacity: .3,\n                scaleRadius: false,\n                latField: 'lat',\n                lngField: 'lng',\n                valueField: 'value',\n//                    useLocalExtrema: true\n            };\n            var heatmapLayer = new HeatmapOverlay(cfg);\n            this.addLayer(heatmapLayer);\n            angular.forEach(locations, function (location) {\n                var latLng = {\n                    lat: location.point_lat_lng[0],\n                    lng: location.point_lat_lng[1]\n                };\n                var locationMarker = new L.Marker(latLng, {icon: MapService.createMarkerIcon('location'), location_data: location}),\n                        popup = new L.Popup(),\n                        popupContent = '',\n                        data = location[type];\n                if (angular.isDefined(data)) {\n                    popupContent = _getLocationTooltip(data, type);\n                    // Heat map\n                    maxValue = (data > maxValue) ? data : maxValue;\n                    if (data > 0) {\n                        heatMapData.push(angular.extend({}, latLng, {value: data, radius: location.radius}));\n                    }\n                }\n\n                popup.setContent('<p><b>' + location.name + '</b><br/>' + popupContent + '</p>');\n                locationMarker.bindPopup(popup, {autoPan: false});\n                locationMarker.on('click', function () {\n                    this.openPopup();\n                });\n                markers.addLayer(locationMarker);\n            });\n            heatmapLayer.setData({max: maxValue, data: heatMapData});\n            LocalizationMapService.addLayer(markers);\n        }\n    };\n    return LocalizationMapService;\n}]);"],"sourceRoot":"/source/"}